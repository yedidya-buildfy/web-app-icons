-- Complete schema for Icon Search App with AI Generation and Admin Dashboard
-- Updated to match production database structure
-- Run this in your Supabase project's SQL editor to create the complete schema

-- Enable UUID extension if not already enabled
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

-- =============================================================================
-- CORE USER MANAGEMENT
-- =============================================================================

-- Create profiles table to store user metadata from OAuth providers and email signups
CREATE TABLE IF NOT EXISTS public.profiles (
  id UUID REFERENCES auth.users(id) ON DELETE CASCADE PRIMARY KEY,
  email TEXT,
  full_name TEXT,
  avatar_url TEXT,
  provider TEXT, -- 'google', 'github', 'email', etc.
  provider_id TEXT, -- The ID from the OAuth provider
  is_super_admin BOOLEAN DEFAULT FALSE,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Enable RLS for profiles
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;

-- Create policies for profiles
CREATE POLICY "Users can view own profile" ON public.profiles FOR SELECT USING (auth.uid() = id);
CREATE POLICY "Users can insert own profile" ON public.profiles FOR INSERT
  WITH CHECK (auth.uid() = id AND COALESCE(is_super_admin, FALSE) = FALSE);
CREATE POLICY "Users can update own profile" ON public.profiles FOR UPDATE
  USING (auth.uid() = id)
  WITH CHECK (auth.uid() = id AND (is_super_admin IS NOT DISTINCT FROM (SELECT is_super_admin FROM public.profiles p WHERE p.id = auth.uid())));

-- Admin can view all profiles
CREATE POLICY "Admin can view all profiles" ON public.profiles FOR SELECT 
  USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND is_super_admin = TRUE));

-- =============================================================================
-- ICON SEARCH AND STORAGE
-- =============================================================================

-- Search logging table
CREATE TABLE IF NOT EXISTS public.searches (
  id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  query text NOT NULL,
  library text NOT NULL,
  user_id UUID REFERENCES public.profiles(id) ON DELETE CASCADE,
  searched_at timestamptz NOT NULL DEFAULT now()
);

-- Optional: table to store favourite icons or search results
CREATE TABLE IF NOT EXISTS public.favourites (
  id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  icon_id text NOT NULL,
  library text NOT NULL,
  added_at timestamptz NOT NULL DEFAULT now()
);

-- Generated icons storage with custom_id field (matches production)
CREATE TABLE IF NOT EXISTS public.generated_icons (
  id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  deterministic_id text NOT NULL, -- sha256(icon_name|image_url) for idempotency
  icon_name text NOT NULL,
  subject text NOT NULL,
  context text NOT NULL,
  style text NOT NULL,
  colors text NOT NULL,
  background text NOT NULL,
  image_url text NOT NULL,
  user_id UUID REFERENCES public.profiles(id) ON DELETE CASCADE,
  custom_id text, -- Custom identifier for generated icons
  created_at timestamptz NOT NULL DEFAULT now(),
  CONSTRAINT generated_icons_deterministic_id_unique UNIQUE (deterministic_id)
);

-- Helpful indexes
CREATE INDEX IF NOT EXISTS generated_icons_created_at_idx ON public.generated_icons (created_at DESC);
CREATE INDEX IF NOT EXISTS generated_icons_subject_idx ON public.generated_icons (subject);
CREATE INDEX IF NOT EXISTS generated_icons_context_idx ON public.generated_icons (context);
CREATE INDEX IF NOT EXISTS generated_icons_style_idx ON public.generated_icons (style);
CREATE INDEX IF NOT EXISTS generated_icons_colors_idx ON public.generated_icons (colors);
CREATE INDEX IF NOT EXISTS generated_icons_background_idx ON public.generated_icons (background);
CREATE INDEX IF NOT EXISTS generated_icons_custom_id_idx ON public.generated_icons (custom_id);

-- View reflecting current schema (context appended last to avoid rename issues)
CREATE OR REPLACE VIEW public.generated_icons_view AS
SELECT id, deterministic_id, icon_name, subject, style, colors, background, image_url, user_id, custom_id, created_at, context
FROM public.generated_icons;

-- =============================================================================
-- USER PROFILE MANAGEMENT
-- =============================================================================

-- Add user profile handling functions and triggers
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS TRIGGER AS $$
BEGIN
  INSERT INTO public.profiles (
    id,
    email,
    full_name,
    avatar_url,
    provider,
    provider_id,
    is_super_admin
  ) VALUES (
    NEW.id,
    NEW.email,
    COALESCE(NEW.raw_user_meta_data->>'full_name', NEW.raw_user_meta_data->>'name'),
    COALESCE(NEW.raw_user_meta_data->>'avatar_url', NEW.raw_user_meta_data->>'picture'),
    COALESCE(NEW.raw_app_meta_data->>'provider', 'email'),
    NEW.raw_user_meta_data->>'provider_id',
    FALSE
  );
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Create trigger to automatically create profile on user signup
DROP TRIGGER IF EXISTS on_auth_user_created ON auth.users;
CREATE TRIGGER on_auth_user_created
  AFTER INSERT ON auth.users
  FOR EACH ROW EXECUTE PROCEDURE public.handle_new_user();

-- Update function to handle profile updates
CREATE OR REPLACE FUNCTION public.handle_user_update()
RETURNS TRIGGER AS $$
BEGIN
  UPDATE public.profiles SET
    email = NEW.email,
    full_name = COALESCE(NEW.raw_user_meta_data->>'full_name', NEW.raw_user_meta_data->>'name', full_name),
    avatar_url = COALESCE(NEW.raw_user_meta_data->>'avatar_url', NEW.raw_user_meta_data->>'picture', avatar_url),
    updated_at = NOW()
  WHERE id = NEW.id;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Prevent client-side admin escalation
CREATE OR REPLACE FUNCTION public.prevent_client_admin_escalation()
RETURNS TRIGGER AS $$
DECLARE
  jwt_claims jsonb := COALESCE(NULLIF(current_setting('request.jwt.claims', true), ''), '{}')::jsonb;
  is_service_role boolean := (jwt_claims ->> 'role') = 'service_role';
  is_requester_admin boolean := EXISTS (
    SELECT 1 FROM public.profiles WHERE id = auth.uid() AND is_super_admin = TRUE
  );
BEGIN
  -- Allow if called with service_role or by a currently authenticated super admin
  IF is_service_role OR is_requester_admin THEN
    RETURN NEW;
  END IF;

  IF TG_OP = 'INSERT' THEN
    IF NEW.is_super_admin IS TRUE THEN
      RAISE EXCEPTION 'Forbidden: cannot set is_super_admin on INSERT';
    END IF;
  ELSIF TG_OP = 'UPDATE' THEN
    IF COALESCE(OLD.is_super_admin, FALSE) IS DISTINCT FROM COALESCE(NEW.is_super_admin, FALSE) THEN
      RAISE EXCEPTION 'Forbidden: cannot modify is_super_admin';
    END IF;
  END IF;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

DROP TRIGGER IF EXISTS prevent_client_admin_escalation_trg ON public.profiles;
CREATE TRIGGER prevent_client_admin_escalation_trg
  BEFORE INSERT OR UPDATE ON public.profiles
  FOR EACH ROW EXECUTE PROCEDURE public.prevent_client_admin_escalation();

-- Create trigger to automatically update profile when user data changes
DROP TRIGGER IF EXISTS on_auth_user_updated ON auth.users;
CREATE TRIGGER on_auth_user_updated
  AFTER UPDATE ON auth.users
  FOR EACH ROW EXECUTE PROCEDURE public.handle_user_update();

-- Add indexes for better performance
CREATE INDEX IF NOT EXISTS idx_profiles_provider ON public.profiles(provider);
CREATE INDEX IF NOT EXISTS idx_profiles_provider_id ON public.profiles(provider_id);
CREATE INDEX IF NOT EXISTS idx_profiles_email ON public.profiles(email);
CREATE INDEX IF NOT EXISTS idx_profiles_is_super_admin ON public.profiles(is_super_admin);

-- =============================================================================
-- USAGE TRACKING AND BILLING SYSTEM
-- =============================================================================

-- Create subscription plans table
CREATE TABLE IF NOT EXISTS public.subscription_plans (
  id TEXT PRIMARY KEY, -- e.g., 'free', 'pro', 'enterprise'
  name TEXT NOT NULL,
  description TEXT,
  price_monthly DECIMAL(10,2) NOT NULL DEFAULT 0.00,
  price_yearly DECIMAL(10,2) NOT NULL DEFAULT 0.00,
  
  -- Monthly limits for different actions
  monthly_icon_searches INTEGER NOT NULL DEFAULT 100, -- API icon searches/pulls
  monthly_icon_downloads INTEGER NOT NULL DEFAULT 50, -- PNG/SVG downloads
  monthly_icon_generation INTEGER NOT NULL DEFAULT 10, -- AI generation
  monthly_generated_usage INTEGER NOT NULL DEFAULT 25, -- Using app-generated icons
  
  -- Feature flags
  unlimited_searches BOOLEAN DEFAULT FALSE,
  unlimited_downloads BOOLEAN DEFAULT FALSE,
  unlimited_generation BOOLEAN DEFAULT FALSE,
  unlimited_generated_usage BOOLEAN DEFAULT FALSE,
  
  -- Plan metadata
  is_active BOOLEAN DEFAULT TRUE,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Insert basic free plan
INSERT INTO public.subscription_plans (id, name, description) VALUES
('free', 'Free', 'Basic plan for all users')
ON CONFLICT (id) DO NOTHING;

-- Create user subscriptions table
CREATE TABLE IF NOT EXISTS public.user_subscriptions (
  id UUID DEFAULT uuid_generate_v4() PRIMARY KEY,
  user_id UUID REFERENCES public.profiles(id) ON DELETE CASCADE NOT NULL,
  plan_id TEXT REFERENCES public.subscription_plans(id) NOT NULL,
  
  -- Billing information
  status TEXT NOT NULL DEFAULT 'active', -- active, canceled, expired, suspended
  billing_cycle TEXT NOT NULL DEFAULT 'monthly', -- monthly, yearly
  current_period_start TIMESTAMPTZ DEFAULT NOW(),
  current_period_end TIMESTAMPTZ DEFAULT (NOW() + INTERVAL '1 month'),
  
  -- Payment tracking
  stripe_subscription_id TEXT, -- For Stripe integration
  stripe_customer_id TEXT,
  
  -- Metadata
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),
  
  -- Ensure one active subscription per user
  CONSTRAINT unique_active_subscription EXCLUDE (user_id WITH =) WHERE (status = 'active')
);

-- Create usage events table for detailed tracking
CREATE TABLE IF NOT EXISTS public.usage_events (
  id UUID DEFAULT uuid_generate_v4() PRIMARY KEY,
  user_id UUID REFERENCES public.profiles(id) ON DELETE CASCADE NOT NULL,
  
  -- Event details
  event_type TEXT NOT NULL, -- 'search', 'download', 'generate', 'use_generated'
  event_subtype TEXT, -- 'png', 'svg', 'copy_svg' for downloads; 'search_query' for searches
  
  -- Resource information
  resource_id TEXT, -- icon_id for searches, generated_icon_id for generations
  resource_metadata JSONB, -- Additional data like query, library, colors, etc.
  
  -- Usage context
  ip_address INET,
  user_agent TEXT,
  
  -- Billing period this event belongs to
  billing_period_start DATE NOT NULL, -- First day of the month this usage counts toward
  
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Create monthly usage summary table for efficient billing queries
CREATE TABLE IF NOT EXISTS public.monthly_usage_summary (
  id UUID DEFAULT uuid_generate_v4() PRIMARY KEY,
  user_id UUID REFERENCES public.profiles(id) ON DELETE CASCADE NOT NULL,
  billing_period_start DATE NOT NULL, -- First day of the month
  
  -- Usage counters
  icon_searches INTEGER DEFAULT 0,
  icon_downloads INTEGER DEFAULT 0, 
  icon_generation INTEGER DEFAULT 0,
  generated_usage INTEGER DEFAULT 0,
  
  -- Plan limits at time of usage (for historical tracking)
  plan_id TEXT,
  plan_searches_limit INTEGER,
  plan_downloads_limit INTEGER,
  plan_generation_limit INTEGER,
  plan_generated_usage_limit INTEGER,
  
  -- Summary metadata
  last_updated TIMESTAMPTZ DEFAULT NOW(),
  created_at TIMESTAMPTZ DEFAULT NOW(),
  
  -- Unique constraint for user + billing period
  CONSTRAINT unique_user_billing_period UNIQUE (user_id, billing_period_start)
);

-- =============================================================================
-- DISCOUNT AND PROMOTION SYSTEM
-- =============================================================================

-- Create discount codes table
CREATE TABLE IF NOT EXISTS public.discount_codes (
  id UUID DEFAULT uuid_generate_v4() PRIMARY KEY,
  code TEXT NOT NULL UNIQUE, -- e.g., 'SAVE20', 'BLACKFRIDAY'
  
  -- Discount details
  discount_type TEXT NOT NULL CHECK (discount_type IN ('percentage', 'fixed')), -- percentage or fixed amount
  discount_amount DECIMAL(10,2) NOT NULL, -- 20.00 for 20% or $20 fixed
  
  -- Usage limits
  max_uses INTEGER DEFAULT NULL, -- NULL = unlimited
  used_count INTEGER DEFAULT 0,
  months_duration INTEGER DEFAULT 1, -- How many months the discount applies
  
  -- Validity period
  valid_from TIMESTAMPTZ DEFAULT NOW(),
  valid_until TIMESTAMPTZ NOT NULL,
  
  -- Plan restrictions (NULL = applies to all plans)
  applicable_plans TEXT[], -- Array of plan IDs this discount applies to
  
  -- Metadata
  description TEXT,
  is_active BOOLEAN DEFAULT TRUE,
  created_by UUID REFERENCES public.profiles(id),
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Create discount code usage tracking
CREATE TABLE IF NOT EXISTS public.discount_code_usage (
  id UUID DEFAULT uuid_generate_v4() PRIMARY KEY,
  discount_code_id UUID REFERENCES public.discount_codes(id) ON DELETE CASCADE,
  user_id UUID REFERENCES public.profiles(id) ON DELETE CASCADE,
  
  -- Usage details
  original_price DECIMAL(10,2) NOT NULL,
  discount_amount DECIMAL(10,2) NOT NULL,
  final_price DECIMAL(10,2) NOT NULL,
  
  -- When and where used
  used_at TIMESTAMPTZ DEFAULT NOW(),
  subscription_id UUID REFERENCES public.user_subscriptions(id),
  
  -- Ensure one use per user per discount code
  CONSTRAINT unique_user_discount_usage UNIQUE (discount_code_id, user_id)
);

-- Create user settings table for preferences
CREATE TABLE IF NOT EXISTS public.user_settings (
  id UUID DEFAULT uuid_generate_v4() PRIMARY KEY,
  user_id UUID REFERENCES public.profiles(id) ON DELETE CASCADE NOT NULL,
  
  -- Settings stored as JSON for flexibility
  settings JSONB NOT NULL DEFAULT '{}',
  
  -- Metadata
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),
  
  -- Ensure one settings record per user
  CONSTRAINT unique_user_settings UNIQUE (user_id)
);

-- =============================================================================
-- INDEXES FOR PERFORMANCE
-- =============================================================================

CREATE INDEX IF NOT EXISTS idx_user_subscriptions_user_id ON public.user_subscriptions(user_id);
CREATE INDEX IF NOT EXISTS idx_user_subscriptions_status ON public.user_subscriptions(status);
CREATE INDEX IF NOT EXISTS idx_user_subscriptions_plan_id ON public.user_subscriptions(plan_id);

CREATE INDEX IF NOT EXISTS idx_usage_events_user_id ON public.usage_events(user_id);
CREATE INDEX IF NOT EXISTS idx_usage_events_event_type ON public.usage_events(event_type);
CREATE INDEX IF NOT EXISTS idx_usage_events_billing_period ON public.usage_events(billing_period_start);
CREATE INDEX IF NOT EXISTS idx_usage_events_created_at ON public.usage_events(created_at DESC);

CREATE INDEX IF NOT EXISTS idx_monthly_usage_user_id ON public.monthly_usage_summary(user_id);
CREATE INDEX IF NOT EXISTS idx_monthly_usage_billing_period ON public.monthly_usage_summary(billing_period_start);

CREATE INDEX IF NOT EXISTS idx_user_settings_user_id ON public.user_settings(user_id);
CREATE INDEX IF NOT EXISTS idx_user_settings_updated_at ON public.user_settings(updated_at DESC);
CREATE INDEX IF NOT EXISTS idx_discount_codes_code ON public.discount_codes(code);
CREATE INDEX IF NOT EXISTS idx_discount_codes_valid_period ON public.discount_codes(valid_from, valid_until);
CREATE INDEX IF NOT EXISTS idx_discount_code_usage_user ON public.discount_code_usage(user_id);
CREATE INDEX IF NOT EXISTS idx_discount_code_usage_code ON public.discount_code_usage(discount_code_id);

-- =============================================================================
-- ROW LEVEL SECURITY POLICIES
-- =============================================================================

-- Enable RLS on all tables
ALTER TABLE public.subscription_plans ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.user_subscriptions ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.usage_events ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.monthly_usage_summary ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.user_settings ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.discount_codes ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.discount_code_usage ENABLE ROW LEVEL SECURITY;

-- RLS Policies for subscription_plans (read-only for all)
CREATE POLICY "Allow read subscription plans to all" ON public.subscription_plans FOR SELECT USING (is_active = true);

-- RLS Policies for user_subscriptions
CREATE POLICY "Users can view own subscription" ON public.user_subscriptions FOR SELECT USING (auth.uid() = user_id);
CREATE POLICY "Users can update own subscription" ON public.user_subscriptions FOR UPDATE USING (auth.uid() = user_id);

-- RLS Policies for usage_events
CREATE POLICY "Users can view own usage events" ON public.usage_events FOR SELECT USING (auth.uid() = user_id);
CREATE POLICY "System can insert usage events" ON public.usage_events FOR INSERT WITH CHECK (true);

-- RLS Policies for monthly_usage_summary
CREATE POLICY "Users can view own usage summary" ON public.monthly_usage_summary FOR SELECT USING (auth.uid() = user_id);
CREATE POLICY "System can manage usage summary" ON public.monthly_usage_summary FOR ALL USING (true);

-- RLS Policies for user_settings
CREATE POLICY "Users can view own settings" ON public.user_settings FOR SELECT 
  USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own settings" ON public.user_settings FOR INSERT 
  WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own settings" ON public.user_settings FOR UPDATE 
  USING (auth.uid() = user_id)
  WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Admin can view all settings" ON public.user_settings FOR SELECT 
  USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND is_super_admin = TRUE));

-- RLS Policies for discount_codes
CREATE POLICY "Admin can manage discount codes" ON public.discount_codes FOR ALL 
  USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND is_super_admin = TRUE));

CREATE POLICY "Users can view active discount codes" ON public.discount_codes FOR SELECT 
  USING (is_active = TRUE AND valid_from <= NOW() AND valid_until >= NOW());

-- RLS Policies for discount_code_usage
CREATE POLICY "Admin can view all discount usage" ON public.discount_code_usage FOR SELECT 
  USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND is_super_admin = TRUE));

CREATE POLICY "Users can view own discount usage" ON public.discount_code_usage FOR SELECT 
  USING (auth.uid() = user_id);

CREATE POLICY "System can insert discount usage" ON public.discount_code_usage FOR INSERT 
  WITH CHECK (true);

-- Allow read to all for generated_icons (keeping existing policy)
DO $$ BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM pg_policies WHERE schemaname = 'public' AND tablename = 'generated_icons' AND policyname = 'Allow read to all'
  ) THEN
    CREATE POLICY "Allow read to all" ON public.generated_icons FOR SELECT USING (true);
  END IF;
END $$;

DO $$ BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM pg_policies WHERE schemaname = 'public' AND tablename = 'generated_icons' AND policyname = 'Allow insert to anon'
  ) THEN
    CREATE POLICY "Allow insert to anon" ON public.generated_icons FOR INSERT WITH CHECK (true);
  END IF;
END $$;

DO $$ BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM pg_policies WHERE schemaname = 'public' AND tablename = 'generated_icons' AND policyname = 'Allow update on conflict'
  ) THEN
    CREATE POLICY "Allow update on conflict" ON public.generated_icons FOR UPDATE USING (true) WITH CHECK (true);
  END IF;
END $$;-- Complete functions for Icon Search App Admin Dashboard
-- These are the working functions from your production database

-- =============================================================================
-- UTILITY FUNCTIONS
-- =============================================================================

-- Create function to get current billing period
CREATE OR REPLACE FUNCTION public.get_billing_period_start(target_date DATE DEFAULT CURRENT_DATE)
RETURNS DATE AS $$
BEGIN
  RETURN DATE_TRUNC('month', target_date)::DATE;
END;
$$ LANGUAGE plpgsql;

-- Create function to track usage event
CREATE OR REPLACE FUNCTION public.track_usage_event(
  p_user_id UUID,
  p_event_type TEXT,
  p_event_subtype TEXT DEFAULT NULL,
  p_resource_id TEXT DEFAULT NULL,
  p_resource_metadata JSONB DEFAULT NULL,
  p_ip_address INET DEFAULT NULL,
  p_user_agent TEXT DEFAULT NULL
)
RETURNS UUID AS $$
DECLARE
  event_id UUID;
  billing_period DATE;
BEGIN
  billing_period := public.get_billing_period_start();
  
  -- Insert usage event
  INSERT INTO public.usage_events (
    user_id, event_type, event_subtype, resource_id, resource_metadata,
    ip_address, user_agent, billing_period_start
  ) VALUES (
    p_user_id, p_event_type, p_event_subtype, p_resource_id, p_resource_metadata,
    p_ip_address, p_user_agent, billing_period
  ) RETURNING id INTO event_id;
  
  -- Update monthly usage summary
  INSERT INTO public.monthly_usage_summary (
    user_id, billing_period_start,
    icon_searches, icon_downloads, icon_generation, generated_usage
  ) VALUES (
    p_user_id, billing_period,
    CASE WHEN p_event_type = 'search' THEN 1 ELSE 0 END,
    CASE WHEN p_event_type = 'download' THEN 1 ELSE 0 END,
    CASE WHEN p_event_type = 'generate' THEN 1 ELSE 0 END,
    CASE WHEN p_event_type = 'use_generated' THEN 1 ELSE 0 END
  )
  ON CONFLICT (user_id, billing_period_start) DO UPDATE SET
    icon_searches = monthly_usage_summary.icon_searches + 
      CASE WHEN p_event_type = 'search' THEN 1 ELSE 0 END,
    icon_downloads = monthly_usage_summary.icon_downloads + 
      CASE WHEN p_event_type = 'download' THEN 1 ELSE 0 END,
    icon_generation = monthly_usage_summary.icon_generation + 
      CASE WHEN p_event_type = 'generate' THEN 1 ELSE 0 END,
    generated_usage = monthly_usage_summary.generated_usage + 
      CASE WHEN p_event_type = 'use_generated' THEN 1 ELSE 0 END,
    last_updated = NOW();
  
  RETURN event_id;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Create function to check usage limits
CREATE OR REPLACE FUNCTION public.check_usage_limits(
  p_user_id UUID,
  p_event_type TEXT,
  p_target_date DATE DEFAULT CURRENT_DATE
)
RETURNS TABLE (
  within_limits BOOLEAN,
  current_usage INTEGER,
  usage_limit INTEGER,
  plan_name TEXT
) AS $$
DECLARE
  billing_period DATE;
  user_plan RECORD;
  user_usage RECORD;
BEGIN
  billing_period := public.get_billing_period_start(p_target_date);
  
  -- Get user's current plan
  SELECT sp.*, us.status INTO user_plan
  FROM public.subscription_plans sp
  JOIN public.user_subscriptions us ON sp.id = us.plan_id
  WHERE us.user_id = p_user_id AND us.status = 'active'
  LIMIT 1;
  
  -- Get user's current usage
  SELECT * INTO user_usage
  FROM public.monthly_usage_summary
  WHERE user_id = p_user_id AND billing_period_start = billing_period;
  
  -- If no usage record exists, create with zeros
  IF user_usage IS NULL THEN
    user_usage := ROW(NULL, p_user_id, billing_period, 0, 0, 0, 0, NULL, NULL, NULL, NULL, NULL, NOW(), NOW())::public.monthly_usage_summary;
  END IF;
  
  -- Default to free plan if no subscription found
  IF user_plan IS NULL THEN
    SELECT * INTO user_plan FROM public.subscription_plans WHERE id = 'free';
  END IF;
  
  -- Check limits based on event type
  CASE p_event_type
    WHEN 'search' THEN
      RETURN QUERY SELECT 
        (user_plan.unlimited_searches OR user_usage.icon_searches < user_plan.monthly_icon_searches),
        user_usage.icon_searches,
        user_plan.monthly_icon_searches,
        user_plan.name;
    WHEN 'download' THEN
      RETURN QUERY SELECT 
        (user_plan.unlimited_downloads OR user_usage.icon_downloads < user_plan.monthly_icon_downloads),
        user_usage.icon_downloads,
        user_plan.monthly_icon_downloads,
        user_plan.name;
    WHEN 'generate' THEN
      RETURN QUERY SELECT 
        (user_plan.unlimited_generation OR user_usage.icon_generation < user_plan.monthly_icon_generation),
        user_usage.icon_generation,
        user_plan.monthly_icon_generation,
        user_plan.name;
    WHEN 'use_generated' THEN
      RETURN QUERY SELECT 
        (user_plan.unlimited_generated_usage OR user_usage.generated_usage < user_plan.monthly_generated_usage),
        user_usage.generated_usage,
        user_plan.monthly_generated_usage,
        user_plan.name;
    ELSE
      RETURN QUERY SELECT FALSE, 0, 0, user_plan.name;
  END CASE;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- =============================================================================
-- DISCOUNT CODE FUNCTIONS
-- =============================================================================

-- Create function to validate and apply discount code
CREATE OR REPLACE FUNCTION public.apply_discount_code(
  p_code TEXT,
  p_user_id UUID,
  p_plan_id TEXT,
  p_billing_cycle TEXT DEFAULT 'monthly'
)
RETURNS TABLE (
  is_valid BOOLEAN,
  discount_amount DECIMAL(10,2),
  final_price DECIMAL(10,2),
  original_price DECIMAL(10,2),
  message TEXT
) AS $$
DECLARE
  discount_record RECORD;
  plan_record RECORD;
  usage_count INTEGER;
  calculated_discount DECIMAL(10,2);
  base_price DECIMAL(10,2);
BEGIN
  -- Get discount code details
  SELECT * INTO discount_record
  FROM public.discount_codes
  WHERE code = UPPER(p_code) AND is_active = TRUE
    AND valid_from <= NOW() AND valid_until >= NOW();
  
  IF discount_record IS NULL THEN
    RETURN QUERY SELECT FALSE, 0.00, 0.00, 0.00, 'Invalid or expired discount code';
    RETURN;
  END IF;
  
  -- Check if user already used this discount
  SELECT COUNT(*) INTO usage_count
  FROM public.discount_code_usage
  WHERE discount_code_id = discount_record.id AND user_id = p_user_id;
  
  IF usage_count > 0 THEN
    RETURN QUERY SELECT FALSE, 0.00, 0.00, 0.00, 'Discount code already used';
    RETURN;
  END IF;
  
  -- Check usage limits
  IF discount_record.max_uses IS NOT NULL AND discount_record.used_count >= discount_record.max_uses THEN
    RETURN QUERY SELECT FALSE, 0.00, 0.00, 0.00, 'Discount code usage limit reached';
    RETURN;
  END IF;
  
  -- Get plan details
  SELECT * INTO plan_record
  FROM public.subscription_plans
  WHERE id = p_plan_id AND is_active = TRUE;
  
  IF plan_record IS NULL THEN
    RETURN QUERY SELECT FALSE, 0.00, 0.00, 0.00, 'Invalid plan';
    RETURN;
  END IF;
  
  -- Check if discount applies to this plan
  IF discount_record.applicable_plans IS NOT NULL AND NOT (p_plan_id = ANY(discount_record.applicable_plans)) THEN
    RETURN QUERY SELECT FALSE, 0.00, 0.00, 0.00, 'Discount code not applicable to this plan';
    RETURN;
  END IF;
  
  -- Calculate base price
  IF p_billing_cycle = 'yearly' THEN
    base_price := plan_record.price_yearly;
  ELSE
    base_price := plan_record.price_monthly;
  END IF;
  
  -- Calculate discount
  IF discount_record.discount_type = 'percentage' THEN
    calculated_discount := ROUND((base_price * discount_record.discount_amount / 100), 2);
  ELSE
    calculated_discount := discount_record.discount_amount;
  END IF;
  
  -- Ensure discount doesn't exceed original price
  calculated_discount := LEAST(calculated_discount, base_price);
  
  RETURN QUERY SELECT 
    TRUE, 
    calculated_discount,
    (base_price - calculated_discount),
    base_price,
    'Discount applied successfully';
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Create function to record discount usage
CREATE OR REPLACE FUNCTION public.record_discount_usage(
  p_code TEXT,
  p_user_id UUID,
  p_subscription_id UUID,
  p_original_price DECIMAL(10,2),
  p_discount_amount DECIMAL(10,2),
  p_final_price DECIMAL(10,2)
)
RETURNS UUID AS $$
DECLARE
  discount_record RECORD;
  usage_id UUID;
BEGIN
  -- Get discount code
  SELECT * INTO discount_record
  FROM public.discount_codes
  WHERE code = UPPER(p_code) AND is_active = TRUE;
  
  IF discount_record IS NULL THEN
    RAISE EXCEPTION 'Invalid discount code';
  END IF;
  
  -- Record usage
  INSERT INTO public.discount_code_usage (
    discount_code_id, user_id, subscription_id,
    original_price, discount_amount, final_price
  ) VALUES (
    discount_record.id, p_user_id, p_subscription_id,
    p_original_price, p_discount_amount, p_final_price
  ) RETURNING id INTO usage_id;
  
  -- Update usage count
  UPDATE public.discount_codes 
  SET used_count = used_count + 1, updated_at = NOW()
  WHERE id = discount_record.id;
  
  RETURN usage_id;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- =============================================================================
-- ADMIN FUNCTIONS
-- =============================================================================

-- Main admin function for customers overview (matches your working production function)
CREATE OR REPLACE FUNCTION public.admin_get_customers_overview(
  p_admin_user_id UUID
)
RETURNS TABLE (
  user_id UUID,
  email TEXT,
  profile_created_at TIMESTAMPTZ,
  current_plan_id TEXT,
  current_plan_name TEXT,
  billing_cycle TEXT,
  estimated_monthly_revenue DECIMAL(10,2),
  generation_count INTEGER,
  download_png_count INTEGER,
  download_svg_count INTEGER,
  copy_svg_count INTEGER,
  total_usage_count INTEGER,
  estimated_total_spend DECIMAL(10,2),
  full_name TEXT,
  is_super_admin BOOLEAN
) AS $$
DECLARE
  is_admin BOOLEAN := FALSE;
BEGIN
  -- Check if user is admin with proper error handling
  SELECT COALESCE(p.is_super_admin, FALSE) INTO is_admin
  FROM public.profiles p
  WHERE p.id = p_admin_user_id;
  
  IF NOT COALESCE(is_admin, FALSE) THEN
    RAISE EXCEPTION 'Access denied: Admin privileges required';
  END IF;

  -- Return customer data from ALL users in auth.users (SECURITY DEFINER bypasses RLS)
  RETURN QUERY
  WITH latest_sub AS (
    SELECT DISTINCT ON (us.user_id)
      us.user_id,
      us.plan_id,
      us.billing_cycle,
      us.status
    FROM public.user_subscriptions us
    WHERE us.status = 'active'
    ORDER BY us.user_id, us.updated_at DESC
  ), usage_agg AS (
    SELECT
      ue.user_id,
      SUM(CASE WHEN ue.event_type = 'generate' THEN 1 ELSE 0 END)::integer AS generation_count,
      SUM(CASE WHEN ue.event_type = 'download' AND ue.event_subtype = 'png' THEN 1 ELSE 0 END)::integer AS download_png_count,
      SUM(CASE WHEN ue.event_type = 'download' AND ue.event_subtype = 'svg' THEN 1 ELSE 0 END)::integer AS download_svg_count,
      SUM(CASE WHEN ue.event_type = 'download' AND ue.event_subtype = 'copy_svg' THEN 1 ELSE 0 END)::integer AS copy_svg_count,
      COUNT(*)::integer AS total_usage_count
    FROM public.usage_events ue
    GROUP BY ue.user_id
  )
  SELECT
    au.id AS user_id,
    au.email::TEXT AS email,
    COALESCE(p.created_at, au.created_at) AS profile_created_at,
    ls.plan_id::TEXT AS current_plan_id,
    sp.name::TEXT AS current_plan_name,
    ls.billing_cycle::TEXT AS billing_cycle,
    (
      CASE WHEN ls.plan_id IS NOT NULL AND (ls.billing_cycle = 'monthly' OR ls.billing_cycle IS NULL)
           THEN COALESCE(sp.price_monthly, 0)
           WHEN ls.plan_id IS NOT NULL AND ls.billing_cycle = 'yearly'
           THEN COALESCE(sp.price_yearly, 0)::numeric / 12
           ELSE 0 END
    )::numeric(10,2) AS estimated_monthly_revenue,
    COALESCE(ua.generation_count, 0) AS generation_count,
    COALESCE(ua.download_png_count, 0) AS download_png_count,
    COALESCE(ua.download_svg_count, 0) AS download_svg_count,
    COALESCE(ua.copy_svg_count, 0) AS copy_svg_count,
    COALESCE(ua.total_usage_count, 0) AS total_usage_count,
    (
      CASE WHEN ls.plan_id IS NOT NULL THEN
        (CASE WHEN ls.billing_cycle = 'yearly' THEN COALESCE(sp.price_yearly, 0)::numeric / 12 ELSE COALESCE(sp.price_monthly, 0) END)
      ELSE 0 END
    )::numeric(10,2) AS estimated_total_spend,
    p.full_name::TEXT AS full_name,
    COALESCE(p.is_super_admin, FALSE) AS is_super_admin
  FROM auth.users au
  LEFT JOIN public.profiles p ON p.id = au.id
  LEFT JOIN latest_sub ls ON ls.user_id = au.id
  LEFT JOIN public.subscription_plans sp ON sp.id = ls.plan_id
  LEFT JOIN usage_agg ua ON ua.user_id = au.id
  ORDER BY COALESCE(sp.price_monthly, 0) DESC, au.created_at DESC;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Function to get all users (for admin diagnostics)
CREATE OR REPLACE FUNCTION public.admin_get_all_users(
  p_admin_user_id UUID DEFAULT NULL
)
RETURNS TABLE (
  user_id UUID,
  email TEXT,
  created_at TIMESTAMPTZ,
  last_sign_in_at TIMESTAMPTZ,
  email_confirmed_at TIMESTAMPTZ,
  full_name TEXT,
  is_super_admin BOOLEAN,
  has_profile BOOLEAN,
  plan_id TEXT,
  plan_name TEXT,
  total_usage_count INTEGER
) AS $$
DECLARE
  is_admin BOOLEAN := FALSE;
BEGIN
  -- Check if user is admin (skip check if called from server-side)
  IF p_admin_user_id IS NOT NULL THEN
    SELECT COALESCE(p.is_super_admin, FALSE) INTO is_admin
    FROM public.profiles p
    WHERE p.id = p_admin_user_id;
    
    IF NOT is_admin THEN
      RAISE EXCEPTION 'Access denied: Admin privileges required';
    END IF;
  END IF;

  -- Return all users from auth.users with profile data if available
  RETURN QUERY
  SELECT
    au.id AS user_id,
    au.email,
    au.created_at,
    au.last_sign_in_at,
    au.email_confirmed_at,
    p.full_name,
    COALESCE(p.is_super_admin, FALSE) AS is_super_admin,
    (p.id IS NOT NULL) AS has_profile,
    us.plan_id,
    sp.name AS plan_name,
    COALESCE(
      (SELECT COUNT(*)::INTEGER FROM public.usage_events ue WHERE ue.user_id = au.id),
      0
    ) AS total_usage_count
  FROM auth.users au
  LEFT JOIN public.profiles p ON p.id = au.id
  LEFT JOIN public.user_subscriptions us ON us.user_id = au.id AND us.status = 'active'
  LEFT JOIN public.subscription_plans sp ON sp.id = us.plan_id
  ORDER BY au.created_at DESC;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Function to create missing profiles
CREATE OR REPLACE FUNCTION public.admin_create_missing_profiles(
  p_admin_user_id UUID
)
RETURNS INTEGER AS $$
DECLARE
  is_admin BOOLEAN := FALSE;
  profiles_created INTEGER := 0;
  user_record RECORD;
BEGIN
  -- Check if user is admin
  SELECT COALESCE(p.is_super_admin, FALSE) INTO is_admin
  FROM public.profiles p
  WHERE p.id = p_admin_user_id;
  
  IF NOT is_admin THEN
    RAISE EXCEPTION 'Access denied: Admin privileges required';
  END IF;

  -- Create profiles for users who don't have them
  FOR user_record IN 
    SELECT au.id, au.email, au.raw_user_meta_data
    FROM auth.users au
    LEFT JOIN public.profiles p ON p.id = au.id
    WHERE p.id IS NULL
  LOOP
    INSERT INTO public.profiles (
      id,
      email,
      full_name,
      avatar_url,
      provider,
      provider_id,
      is_super_admin
    ) VALUES (
      user_record.id,
      user_record.email,
      COALESCE(
        user_record.raw_user_meta_data->>'full_name',
        user_record.raw_user_meta_data->>'name'
      ),
      COALESCE(
        user_record.raw_user_meta_data->>'avatar_url',
        user_record.raw_user_meta_data->>'picture'
      ),
      COALESCE(
        user_record.raw_user_meta_data->>'provider',
        'email'
      ),
      user_record.raw_user_meta_data->>'provider_id',
      FALSE
    );
    
    profiles_created := profiles_created + 1;
  END LOOP;
  
  RETURN profiles_created;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Admin plan management functions
CREATE OR REPLACE FUNCTION public.admin_create_plan(
  p_admin_user_id UUID,
  p_id TEXT,
  p_name TEXT,
  p_description TEXT,
  p_price_monthly DECIMAL(10,2),
  p_price_yearly DECIMAL(10,2),
  p_monthly_icon_searches INTEGER,
  p_monthly_icon_downloads INTEGER,
  p_monthly_icon_generation INTEGER,
  p_monthly_generated_usage INTEGER,
  p_unlimited_searches BOOLEAN DEFAULT FALSE,
  p_unlimited_downloads BOOLEAN DEFAULT FALSE,
  p_unlimited_generation BOOLEAN DEFAULT FALSE,
  p_unlimited_generated_usage BOOLEAN DEFAULT FALSE
)
RETURNS UUID AS $$
DECLARE
  plan_uuid UUID;
BEGIN
  -- Check if user is admin
  IF NOT EXISTS (SELECT 1 FROM public.profiles WHERE id = p_admin_user_id AND is_super_admin = TRUE) THEN
    RAISE EXCEPTION 'Access denied: Admin privileges required';
  END IF;
  
  -- Create plan
  INSERT INTO public.subscription_plans (
    id, name, description, price_monthly, price_yearly,
    monthly_icon_searches, monthly_icon_downloads, monthly_icon_generation, monthly_generated_usage,
    unlimited_searches, unlimited_downloads, unlimited_generation, unlimited_generated_usage
  ) VALUES (
    p_id, p_name, p_description, p_price_monthly, p_price_yearly,
    p_monthly_icon_searches, p_monthly_icon_downloads, p_monthly_icon_generation, p_monthly_generated_usage,
    p_unlimited_searches, p_unlimited_downloads, p_unlimited_generation, p_unlimited_generated_usage
  );
  
  RETURN gen_random_uuid(); -- Return success indicator
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE FUNCTION public.admin_update_plan(
  p_admin_user_id UUID,
  p_id TEXT,
  p_name TEXT,
  p_description TEXT,
  p_price_monthly DECIMAL(10,2),
  p_price_yearly DECIMAL(10,2),
  p_monthly_icon_searches INTEGER,
  p_monthly_icon_downloads INTEGER,
  p_monthly_icon_generation INTEGER,
  p_monthly_generated_usage INTEGER,
  p_unlimited_searches BOOLEAN DEFAULT FALSE,
  p_unlimited_downloads BOOLEAN DEFAULT FALSE,
  p_unlimited_generation BOOLEAN DEFAULT FALSE,
  p_unlimited_generated_usage BOOLEAN DEFAULT FALSE
)
RETURNS BOOLEAN AS $$
BEGIN
  -- Check if user is admin
  IF NOT EXISTS (SELECT 1 FROM public.profiles WHERE id = p_admin_user_id AND is_super_admin = TRUE) THEN
    RAISE EXCEPTION 'Access denied: Admin privileges required';
  END IF;
  
  -- Update plan
  UPDATE public.subscription_plans SET
    name = p_name,
    description = p_description,
    price_monthly = p_price_monthly,
    price_yearly = p_price_yearly,
    monthly_icon_searches = p_monthly_icon_searches,
    monthly_icon_downloads = p_monthly_icon_downloads,
    monthly_icon_generation = p_monthly_icon_generation,
    monthly_generated_usage = p_monthly_generated_usage,
    unlimited_searches = p_unlimited_searches,
    unlimited_downloads = p_unlimited_downloads,
    unlimited_generation = p_unlimited_generation,
    unlimited_generated_usage = p_unlimited_generated_usage,
    updated_at = NOW()
  WHERE id = p_id;
  
  RETURN TRUE;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE FUNCTION public.admin_delete_plan(
  p_admin_user_id UUID,
  p_id TEXT
)
RETURNS BOOLEAN AS $$
BEGIN
  -- Check if user is admin
  IF NOT EXISTS (SELECT 1 FROM public.profiles WHERE id = p_admin_user_id AND is_super_admin = TRUE) THEN
    RAISE EXCEPTION 'Access denied: Admin privileges required';
  END IF;
  
  -- Prevent deletion of free plan
  IF p_id = 'free' THEN
    RAISE EXCEPTION 'Cannot delete the free plan';
  END IF;
  
  -- Check if plan is in use
  IF EXISTS (SELECT 1 FROM public.user_subscriptions WHERE plan_id = p_id AND status = 'active') THEN
    RAISE EXCEPTION 'Cannot delete plan with active subscriptions';
  END IF;
  
  -- Deactivate instead of delete to preserve history
  UPDATE public.subscription_plans SET is_active = FALSE, updated_at = NOW()
  WHERE id = p_id;
  
  RETURN TRUE;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;-- Migration: Fix Usage Tracking System
-- Split into two metrics: icons_generated vs unique_icons_used
-- Date: 2025-08-13

-- =============================================================================
-- 1. UPDATE USAGE EVENTS TABLE STRUCTURE
-- =============================================================================

-- Add new fields to track unique icon usage
ALTER TABLE public.usage_events ADD COLUMN IF NOT EXISTS icon_identifier TEXT;
ALTER TABLE public.usage_events ADD COLUMN IF NOT EXISTS icon_source TEXT; -- 'generated' or 'search'

-- Create index for efficient unique counting
CREATE INDEX IF NOT EXISTS idx_usage_events_icon_identifier ON public.usage_events(user_id, icon_identifier);
CREATE INDEX IF NOT EXISTS idx_usage_events_icon_source ON public.usage_events(icon_source);

-- =============================================================================
-- 2. UPDATE MONTHLY USAGE SUMMARY TABLE
-- =============================================================================

-- Replace old counters with new split metrics
ALTER TABLE public.monthly_usage_summary DROP COLUMN IF EXISTS icon_downloads;
ALTER TABLE public.monthly_usage_summary DROP COLUMN IF EXISTS icon_generation;
ALTER TABLE public.monthly_usage_summary DROP COLUMN IF EXISTS generated_usage;

-- Add new split metrics
ALTER TABLE public.monthly_usage_summary ADD COLUMN IF NOT EXISTS icons_generated INTEGER DEFAULT 0;
ALTER TABLE public.monthly_usage_summary ADD COLUMN IF NOT EXISTS unique_icons_used INTEGER DEFAULT 0;

-- =============================================================================
-- 3. CREATE IMPROVED USAGE TRACKING FUNCTIONS
-- =============================================================================

-- Updated track_usage_event function with unique icon tracking
CREATE OR REPLACE FUNCTION public.track_usage_event(
  p_user_id UUID,
  p_event_type TEXT,
  p_event_subtype TEXT DEFAULT NULL,
  p_resource_id TEXT DEFAULT NULL,
  p_resource_metadata JSONB DEFAULT NULL,
  p_ip_address INET DEFAULT NULL,
  p_user_agent TEXT DEFAULT NULL,
  p_icon_identifier TEXT DEFAULT NULL, -- New: unique identifier for the icon
  p_icon_source TEXT DEFAULT NULL -- New: 'generated' or 'search'
)
RETURNS UUID AS $$
DECLARE
  event_id UUID;
  billing_period DATE;
  is_unique_usage BOOLEAN := FALSE;
  is_new_generation BOOLEAN := FALSE;
BEGIN
  billing_period := public.get_billing_period_start();
  
  -- Insert usage event
  INSERT INTO public.usage_events (
    user_id, event_type, event_subtype, resource_id, resource_metadata,
    ip_address, user_agent, billing_period_start, icon_identifier, icon_source
  ) VALUES (
    p_user_id, p_event_type, p_event_subtype, p_resource_id, p_resource_metadata,
    p_ip_address, p_user_agent, billing_period, p_icon_identifier, p_icon_source
  ) RETURNING id INTO event_id;
  
  -- Check if this is a unique icon usage (first time this user uses this icon)
  IF p_icon_identifier IS NOT NULL AND p_event_type IN ('download', 'use_generated') THEN
    SELECT NOT EXISTS (
      SELECT 1 FROM public.usage_events 
      WHERE user_id = p_user_id 
        AND icon_identifier = p_icon_identifier 
        AND event_type IN ('download', 'use_generated')
        AND id != event_id
    ) INTO is_unique_usage;
  END IF;
  
  -- Check if this is a new generation
  IF p_event_type = 'generate' THEN
    is_new_generation := TRUE;
  END IF;
  
  -- Update monthly usage summary with new logic
  INSERT INTO public.monthly_usage_summary (
    user_id, billing_period_start, icon_searches, icons_generated, unique_icons_used
  ) VALUES (
    p_user_id, billing_period,
    CASE WHEN p_event_type = 'search' THEN 1 ELSE 0 END,
    CASE WHEN is_new_generation THEN 1 ELSE 0 END,
    CASE WHEN is_unique_usage THEN 1 ELSE 0 END
  )
  ON CONFLICT (user_id, billing_period_start) DO UPDATE SET
    icon_searches = monthly_usage_summary.icon_searches + 
      CASE WHEN p_event_type = 'search' THEN 1 ELSE 0 END,
    icons_generated = monthly_usage_summary.icons_generated + 
      CASE WHEN is_new_generation THEN 1 ELSE 0 END,
    unique_icons_used = monthly_usage_summary.unique_icons_used + 
      CASE WHEN is_unique_usage THEN 1 ELSE 0 END,
    last_updated = NOW();
  
  RETURN event_id;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- =============================================================================
-- 4. CREATE FUNCTION TO GET CURRENT USAGE STATS
-- =============================================================================

CREATE OR REPLACE FUNCTION public.get_user_usage_stats(
  p_user_id UUID,
  p_billing_period_start DATE DEFAULT NULL
)
RETURNS TABLE (
  icons_generated_count INTEGER,
  unique_icons_used_count INTEGER,
  total_searches INTEGER,
  period_start DATE
) AS $$
DECLARE
  billing_period DATE;
BEGIN
  billing_period := COALESCE(p_billing_period_start, public.get_billing_period_start());
  
  RETURN QUERY
  WITH direct_stats AS (
    -- Get stats from monthly summary if available
    SELECT 
      COALESCE(mus.icons_generated, 0) as summary_generated,
      COALESCE(mus.unique_icons_used, 0) as summary_used,
      COALESCE(mus.icon_searches, 0) as summary_searches
    FROM public.monthly_usage_summary mus
    WHERE mus.user_id = p_user_id AND mus.billing_period_start = billing_period
  ), calculated_stats AS (
    -- Calculate from events as backup/verification
    SELECT 
      COUNT(CASE WHEN ue.event_type = 'generate' THEN 1 END)::integer as calc_generated,
      COUNT(DISTINCT CASE 
        WHEN ue.event_type IN ('download', 'use_generated') AND ue.icon_identifier IS NOT NULL 
        THEN ue.icon_identifier 
      END)::integer as calc_used,
      COUNT(CASE WHEN ue.event_type = 'search' THEN 1 END)::integer as calc_searches
    FROM public.usage_events ue
    WHERE ue.user_id = p_user_id AND ue.billing_period_start = billing_period
  )
  SELECT 
    GREATEST(COALESCE(ds.summary_generated, 0), COALESCE(cs.calc_generated, 0)) as icons_generated_count,
    GREATEST(COALESCE(ds.summary_used, 0), COALESCE(cs.calc_used, 0)) as unique_icons_used_count,
    GREATEST(COALESCE(ds.summary_searches, 0), COALESCE(cs.calc_searches, 0)) as total_searches,
    billing_period as period_start
  FROM direct_stats ds
  CROSS JOIN calculated_stats cs;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;-- Migration: Update Admin Functions for New Usage Metrics
-- Date: 2025-08-13

-- =============================================================================
-- UPDATED ADMIN CUSTOMERS OVERVIEW FUNCTION
-- =============================================================================

CREATE OR REPLACE FUNCTION public.admin_get_customers_overview(
  p_admin_user_id UUID
)
RETURNS TABLE (
  user_id UUID,
  email TEXT,
  profile_created_at TIMESTAMPTZ,
  current_plan_id TEXT,
  current_plan_name TEXT,
  billing_cycle TEXT,
  estimated_monthly_revenue DECIMAL(10,2),
  icons_generated INTEGER,        -- NEW: Count of unique icons this user generated
  unique_icons_used INTEGER,      -- NEW: Count of unique existing icons user downloaded
  download_png_count INTEGER,     -- Keep for backwards compatibility
  download_svg_count INTEGER,     -- Keep for backwards compatibility
  copy_svg_count INTEGER,         -- Keep for backwards compatibility
  total_searches INTEGER,         -- NEW: Total search count
  total_usage_count INTEGER,      -- Keep total for overall activity
  estimated_total_spend DECIMAL(10,2),
  full_name TEXT,
  is_super_admin BOOLEAN
) AS $$
DECLARE
  is_admin BOOLEAN := FALSE;
BEGIN
  -- Check if user is admin
  SELECT COALESCE(p.is_super_admin, FALSE) INTO is_admin
  FROM public.profiles p
  WHERE p.id = p_admin_user_id;
  
  IF NOT COALESCE(is_admin, FALSE) THEN
    RAISE EXCEPTION 'Access denied: Admin privileges required';
  END IF;

  RETURN QUERY
  WITH latest_sub AS (
    SELECT DISTINCT ON (us.user_id)
      us.user_id,
      us.plan_id,
      us.billing_cycle,
      us.status
    FROM public.user_subscriptions us
    WHERE us.status = 'active'
    ORDER BY us.user_id, us.updated_at DESC
  ), 
  generated_icons_stats AS (
    -- Count actual generated icons from generated_icons table
    SELECT 
      gi.user_id,
      COUNT(DISTINCT gi.id)::integer as icons_generated_count
    FROM public.generated_icons gi
    WHERE gi.user_id IS NOT NULL
    GROUP BY gi.user_id
  ),
  usage_summary_stats AS (
    -- Get current month usage from summary table
    SELECT
      mus.user_id,
      COALESCE(mus.icons_generated, 0)::integer as summary_generated,
      COALESCE(mus.unique_icons_used, 0)::integer as summary_used,
      COALESCE(mus.icon_searches, 0)::integer as summary_searches
    FROM public.monthly_usage_summary mus
    WHERE mus.billing_period_start = public.get_billing_period_start()
  ),
  usage_events_stats AS (
    -- Calculate from events table for detailed breakdown
    SELECT
      ue.user_id,
      COUNT(CASE WHEN ue.event_type = 'generate' THEN 1 END)::integer AS events_generated,
      COUNT(DISTINCT CASE 
        WHEN ue.event_type IN ('download', 'use_generated') AND ue.icon_identifier IS NOT NULL 
        THEN ue.icon_identifier 
      END)::integer AS events_unique_used,
      SUM(CASE WHEN ue.event_type = 'download' AND ue.event_subtype = 'png' THEN 1 ELSE 0 END)::integer AS download_png_count,
      SUM(CASE WHEN ue.event_type = 'download' AND ue.event_subtype = 'svg' THEN 1 ELSE 0 END)::integer AS download_svg_count,
      SUM(CASE WHEN ue.event_type = 'download' AND ue.event_subtype = 'copy_svg' THEN 1 ELSE 0 END)::integer AS copy_svg_count,
      COUNT(CASE WHEN ue.event_type = 'search' THEN 1 END)::integer AS search_count,
      COUNT(*)::integer AS total_usage_count
    FROM public.usage_events ue
    GROUP BY ue.user_id
  )
  SELECT
    au.id AS user_id,
    au.email::TEXT AS email,
    COALESCE(p.created_at, au.created_at) AS profile_created_at,
    ls.plan_id::TEXT AS current_plan_id,
    sp.name::TEXT AS current_plan_name,
    ls.billing_cycle::TEXT AS billing_cycle,
    (
      CASE WHEN ls.plan_id IS NOT NULL AND (ls.billing_cycle = 'monthly' OR ls.billing_cycle IS NULL)
           THEN COALESCE(sp.price_monthly, 0)
           WHEN ls.plan_id IS NOT NULL AND ls.billing_cycle = 'yearly'
           THEN COALESCE(sp.price_yearly, 0)::numeric / 12
           ELSE 0 END
    )::numeric(10,2) AS estimated_monthly_revenue,
    
    -- NEW METRICS: Use the highest count between different sources
    GREATEST(
      COALESCE(gis.icons_generated_count, 0),
      COALESCE(uss.summary_generated, 0),
      COALESCE(ues.events_generated, 0)
    ) AS icons_generated,
    
    GREATEST(
      COALESCE(uss.summary_used, 0),
      COALESCE(ues.events_unique_used, 0)
    ) AS unique_icons_used,
    
    -- Keep existing metrics for backwards compatibility
    COALESCE(ues.download_png_count, 0) AS download_png_count,
    COALESCE(ues.download_svg_count, 0) AS download_svg_count,
    COALESCE(ues.copy_svg_count, 0) AS copy_svg_count,
    
    GREATEST(
      COALESCE(uss.summary_searches, 0),
      COALESCE(ues.search_count, 0)
    ) AS total_searches,
    
    COALESCE(ues.total_usage_count, 0) AS total_usage_count,
    
    (
      CASE WHEN ls.plan_id IS NOT NULL THEN
        (CASE WHEN ls.billing_cycle = 'yearly' THEN COALESCE(sp.price_yearly, 0)::numeric / 12 ELSE COALESCE(sp.price_monthly, 0) END)
      ELSE 0 END
    )::numeric(10,2) AS estimated_total_spend,
    p.full_name::TEXT AS full_name,
    COALESCE(p.is_super_admin, FALSE) AS is_super_admin
  FROM auth.users au
  LEFT JOIN public.profiles p ON p.id = au.id
  LEFT JOIN latest_sub ls ON ls.user_id = au.id
  LEFT JOIN public.subscription_plans sp ON sp.id = ls.plan_id
  LEFT JOIN generated_icons_stats gis ON gis.user_id = au.id
  LEFT JOIN usage_summary_stats uss ON uss.user_id = au.id
  LEFT JOIN usage_events_stats ues ON ues.user_id = au.id
  ORDER BY COALESCE(sp.price_monthly, 0) DESC, au.created_at DESC;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- =============================================================================
-- HELPER FUNCTION TO SYNC GENERATED ICONS WITH USAGE TRACKING
-- =============================================================================

CREATE OR REPLACE FUNCTION public.sync_generated_icons_tracking()
RETURNS INTEGER AS $$
DECLARE
  synced_count INTEGER := 0;
  icon_record RECORD;
BEGIN
  -- Create usage events for generated icons that don't have tracking yet
  FOR icon_record IN 
    SELECT 
      gi.id,
      gi.user_id,
      gi.icon_name,
      gi.deterministic_id,
      gi.created_at
    FROM public.generated_icons gi
    LEFT JOIN public.usage_events ue ON (
      ue.event_type = 'generate' 
      AND ue.resource_id = gi.id::text 
      AND ue.user_id = gi.user_id
    )
    WHERE gi.user_id IS NOT NULL 
      AND ue.id IS NULL -- No existing tracking event
  LOOP
    INSERT INTO public.usage_events (
      user_id,
      event_type,
      event_subtype,
      resource_id,
      resource_metadata,
      icon_identifier,
      icon_source,
      billing_period_start,
      created_at
    ) VALUES (
      icon_record.user_id,
      'generate',
      'ai_generation',
      icon_record.id::text,
      jsonb_build_object(
        'icon_name', icon_record.icon_name,
        'deterministic_id', icon_record.deterministic_id
      ),
      icon_record.deterministic_id, -- Use deterministic_id as unique identifier
      'generated',
      public.get_billing_period_start(icon_record.created_at::date),
      icon_record.created_at
    );
    
    synced_count := synced_count + 1;
  END LOOP;
  
  -- Update monthly summaries
  INSERT INTO public.monthly_usage_summary (
    user_id, 
    billing_period_start, 
    icons_generated,
    unique_icons_used,
    icon_searches
  )
  SELECT 
    ue.user_id,
    ue.billing_period_start,
    COUNT(CASE WHEN ue.event_type = 'generate' THEN 1 END)::integer,
    COUNT(DISTINCT CASE 
      WHEN ue.event_type IN ('download', 'use_generated') AND ue.icon_identifier IS NOT NULL 
      THEN ue.icon_identifier 
    END)::integer,
    COUNT(CASE WHEN ue.event_type = 'search' THEN 1 END)::integer
  FROM public.usage_events ue
  WHERE ue.user_id IS NOT NULL
  GROUP BY ue.user_id, ue.billing_period_start
  ON CONFLICT (user_id, billing_period_start) DO UPDATE SET
    icons_generated = GREATEST(monthly_usage_summary.icons_generated, EXCLUDED.icons_generated),
    unique_icons_used = GREATEST(monthly_usage_summary.unique_icons_used, EXCLUDED.unique_icons_used),
    icon_searches = GREATEST(monthly_usage_summary.icon_searches, EXCLUDED.icon_searches),
    last_updated = NOW();
  
  RETURN synced_count;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;